package disruptor

// import (
// 	"sync/atomic"
// 	"testing"
// )

// const BufferSize = 2048
// const BufferMask = BufferSize - 1

// type Sequence [8]uint64 // avoids false sharing

// func BenchmarkDisruptor(b *testing.B) {
// 	var ring [BufferSize]int // the ring buffer
// 	var cseq, pseq Sequence  // consumer and producer sequence number (+padding)
// 	iterations := uint64(b.N)

// 	go func() {
// 		var seq, max_seq Sequence
// 		for seq[0] = uint64(0); seq[0] < iterations; seq[0]++ {
// 			for seq[0] >= max_seq[0] {
// 				// busy spin until there is room for writing--TODO: sleep/yield otherwise
// 				max_seq[0] = atomic.LoadUint64(&cseq[0]) + BufferSize - 2
// 			}

// 			ring[seq[0]&BufferMask] = int(seq[0])  // send the message
// 			atomic.StoreUint64(&pseq[0], seq[0]+1) // Better: LazyStoreUint64
// 		}
// 	}()

// 	var seq, max_seq Sequence
// 	for seq[0] = uint64(0); seq[0] < iterations; seq[0]++ {
// 		for seq[0] >= max_seq[0] {
// 			// busy spin until there is data available--TODO: sleep/yield otherwise?
// 			max_seq[0] = atomic.LoadUint64(&pseq[0])
// 		}

// 		///*val := */ ring[seq[0]&BufferMask]  // data can now be read from ring[seq&BufferMask].
// 		//cseq[0] = seq[0]
// 		atomic.StoreUint64(&cseq[0], seq[0]) // Better: LazyStoreUint64()

// 		// if val != int(seq[0]) {
// 		// 	panic("invalid result")
// 		// }
// 	}
// }
